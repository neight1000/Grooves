<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DUB MODE — Material UI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="module" src="https://unpkg.com/@material/web/all.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/@material/web/all.css">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #FFF;
      font-family: Roboto, sans-serif;
      height: 100%;
      overflow: hidden;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
      width: 100%;
      height: 100%;
    }
    .interface {
      position: relative;
      z-index: 1;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 1em;
      padding: 1em;
      background: rgba(0, 0, 0, 0.9);
    }
    h1 {
      text-align: center;
      margin: 0;
      padding: 0.5em;
      background: rgba(0, 0, 0, 0.95);
      color: #FFF;
    }
    md-slider, md-select {
      width: 100%;
    }
  </style>
</head>
<body>
<h1>DUB MODE — AMBIENT INTERFACE</h1>
<canvas id="waveCanvas"></canvas>
<div class="interface">
  <md-outlined-select id="preset" label="Preset">
    <md-select-option value="greenhouse"><div slot="headline">Greenhouse</div></md-select-option>
    <md-select-option value="deepspace"><div slot="headline">Deep Space</div></md-select-option>
    <md-select-option value="daylight"><div slot="headline">Daylight</div></md-select-option>
  </md-outlined-select>

  <md-slider id="delayTime" min="0.1" max="1.5" value="0.8" step="0.01" labeled></md-slider>
  <md-slider id="feedback" min="0" max="0.95" value="0.75" step="0.01" labeled></md-slider>
  <md-slider id="filter" min="200" max="5000" value="1000" step="1" labeled></md-slider>
  <md-slider id="volume" min="0" max="100" value="60" labeled></md-slider>
</div>

<script>
const canvas = document.getElementById('waveCanvas');
const ctx = canvas.getContext('2d');

let audioCtx, analyser, masterGain, bufferLength, dataArray;
let currentColor = "#FFF";

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function frequencyToColor(freq) {
  const hue = Math.floor((freq - 100) / 500 * 270);
  return `hsl(${hue}, 100%, 60%)`;
}

function getPreset(preset) {
  const presets = {
    greenhouse: { min: 150, max: 350 },
    deepspace: { min: 60, max: 250 },
    daylight: { min: 300, max: 600 }
  };
  return presets[preset] || presets.greenhouse;
}

function playDubTone() {
  if (!audioCtx) return;

  const presetEl = document.getElementById('preset');
  const selected = presetEl && presetEl.value ? presetEl.value : 'greenhouse';
  const preset = getPreset(selected);
  const freq = preset.min + Math.random() * (preset.max - preset.min);
  const duration = 1.5 + Math.random();
  const peakVol = 0.1 + Math.random() * 0.1;
  currentColor = frequencyToColor(freq);

  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

  const gainNode = audioCtx.createGain();
  gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
  gainNode.gain.linearRampToValueAtTime(peakVol, audioCtx.currentTime + 0.2);
  gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);

  const delay = audioCtx.createDelay();
  delay.delayTime.value = parseFloat(document.getElementById('delayTime').value);

  const feedback = audioCtx.createGain();
  feedback.gain.value = parseFloat(document.getElementById('feedback').value);
  delay.connect(feedback);
  feedback.connect(delay);

  const filter = audioCtx.createBiquadFilter();
  filter.type = "lowpass";
  filter.frequency.value = parseFloat(document.getElementById('filter').value);

  osc.connect(gainNode);
  gainNode.connect(filter);
  filter.connect(delay);
  delay.connect(masterGain);
  gainNode.connect(analyser);

  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function scheduleTones() {
  playDubTone();
  setTimeout(scheduleTones, 900 + Math.random() * 400);
}

function animateWaveform() {
  requestAnimationFrame(animateWaveform);
  if (!analyser) return;
  analyser.getByteTimeDomainData(dataArray);

  ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.lineWidth = 2;
  ctx.strokeStyle = currentColor;
  ctx.beginPath();
  const sliceWidth = canvas.width / bufferLength;
  let x = 0;
  for (let i = 0; i < bufferLength; i++) {
    const v = dataArray[i] / 128.0;
    const y = v * canvas.height / 2;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
    x += sliceWidth;
  }
  ctx.stroke();
}

function setVolume(val) {
  if (masterGain) masterGain.gain.setValueAtTime(val / 100, audioCtx.currentTime);
}
document.getElementById('volume').addEventListener('input', () => {
  setVolume(document.getElementById('volume').value);
});

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  bufferLength = analyser.frequencyBinCount;
  dataArray = new Uint8Array(bufferLength);
  masterGain = audioCtx.createGain();
  masterGain.connect(audioCtx.destination);
  setVolume(document.getElementById('volume').value);
  scheduleTones();
  animateWaveform();
}

document.body.addEventListener('click', initAudio, { once: true });
document.body.addEventListener('touchstart', initAudio, { once: true });
</script>
</body>
</html>