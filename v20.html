<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Plantasia App v27 â€“ Ensemble & Chorus</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0; padding: 0;
      background: black; color: white;
      font-family: monospace; overflow: hidden;
    }
    canvas {
      position: absolute; top: 0; left: 0;
      width: 100vw; height: 100vh; z-index: 0;
    }
    .ui {
      position: absolute; bottom: 0; width: 100%;
      background: rgba(0, 0, 0, 0.85);
      padding: 10px; display: flex; flex-wrap: wrap;
      justify-content: center; gap: 10px; z-index: 1;
    }
    .ui label {
      font-size: 10px; display: block; text-align: center;
    }
    .ui input[type="range"], .ui select {
      width: 90px;
    }
    .ui button {
      font-size: 12px; padding: 4px 8px;
      background: transparent; border: 1px solid white;
      color: white; cursor: pointer;
    }
    #infoDisplay {
      position: absolute; top: 10px; left: 10px;
      z-index: 2; background: rgba(0,0,0,0.6);
      color: white; font-size: 12px; padding: 10px;
      display: none; white-space: pre;
    }
  </style>
</head>
<body>
  <canvas id="waveCanvas"></canvas>
  <div id="infoDisplay"></div>
  <div class="ui">
    <div>
      <label>Preset</label>
      <select id="preset">
        <option value="plants">Plants</option>
        <option value="mold">Mold</option>
        <option value="bacteria">Bacteria</option>
        <option value="mushrooms">Mushrooms</option>
        <option value="harmony">Lifeform Harmony</option>
      </select>
    </div>
    <div><label>Delay</label><input type="range" id="delay" min="0.01" max="2.0" step="0.01" value="0.6"></div>
    <div><label>Echo</label><input type="range" id="echo" min="0" max="1.0" step="0.01" value="0.4"></div>
    <div><label>Reverb</label><input type="range" id="reverb" min="0" max="1.0" step="0.01" value="0.4"></div>
    <div><label>Filter</label><input type="range" id="filter" min="100" max="8000" step="10" value="1200"></div>
    <div><label>Frequency</label><input type="range" id="freq" min="50" max="1000" step="1" value="174"></div>
    <div><label>Volume</label><input type="range" id="volume" min="0" max="100" value="60"></div>
    <div><label>BPM</label><input type="range" id="bpm" min="40" max="180" value="90"></div>
    <button id="play">PLAY</button>
    <button id="stop">STOP</button>
    <button id="toggleDisplay">TOGGLE DATA</button>
  </div>
  <script>
    // UI references
    const preset = document.getElementById('preset'),
          delayCtrl = document.getElementById('delay'),
          echoCtrl = document.getElementById('echo'),
          reverbCtrl = document.getElementById('reverb'),
          filterCtrl = document.getElementById('filter'),
          freqCtrl = document.getElementById('freq'),
          volumeCtrl = document.getElementById('volume'),
          bpmCtrl = document.getElementById('bpm'),
          playBtn = document.getElementById('play'),
          stopBtn = document.getElementById('stop'),
          toggleBtn = document.getElementById('toggleDisplay'),
          infoDisplay = document.getElementById('infoDisplay'),
          canvas = document.getElementById('waveCanvas'),
          ctx = canvas.getContext('2d');

    let audioCtx, analyser, masterGain, reverbNode, reverbFeedback, bufferLength, dataArray;
    let chorusLFO, chorusGain;
    let bpmTimer = null, stopped = true;
    let trailFrames = [], currentWaveColor = "#00FF7F";

    const presetSettings = {
      plants:     { scale: [174, 285, 396, 417, 528], color: "#00FF7F" },
      mold:       { scale: [432, 639, 741],           color: "#8A2BE2" },
      bacteria:   { scale: [528, 554, 585, 728],      color: "#FF4500" },
      mushrooms:  { scale: [417, 444, 528, 639],      color: "#FFD700" },
      harmony:    { scale: [432, 528, 639, 741, 852], color: "#00FFFF" }
    };

    function getScale() {
      return presetSettings[preset.value]?.scale || [174,220,261];
    }
    function getColor() {
      return presetSettings[preset.value]?.color || "#FFFFFF";
    }

    function initAudio() {
      if (audioCtx) return;
      canvas.width = innerWidth; canvas.height = innerHeight;
      window.addEventListener("resize", () => {
        canvas.width = innerWidth; canvas.height = innerHeight;
      });

      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      audioCtx.resume();

      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      bufferLength = analyser.frequencyBinCount;
      dataArray = new Uint8Array(bufferLength);

      masterGain = audioCtx.createGain();
      masterGain.gain.value = parseFloat(volumeCtrl.value) / 100;

      reverbNode = audioCtx.createDelay();
      reverbFeedback = audioCtx.createGain();
      reverbNode.delayTime = parseFloat(reverbCtrl.value);
      reverbFeedback.gain.value = parseFloat(reverbCtrl.value);
      reverbNode.connect(reverbFeedback);
      reverbFeedback.connect(reverbNode);
      reverbNode.connect(masterGain);

      masterGain.connect(audioCtx.destination);

      // Chorus LFO
      chorusLFO = audioCtx.createOscillator();
      chorusLFO.type = "sine";
      chorusLFO.frequency.value = 0.2;
      chorusGain = audioCtx.createGain();
      chorusGain.gain.value = 5;  // cents
      chorusLFO.connect(chorusGain);
      chorusLFO.start();

      animate();
    }

    function playTone(freqVal) {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const filterNode = audioCtx.createBiquadFilter();
      filterNode.type = "lowpass";
      filterNode.frequency.value = parseFloat(filterCtrl.value);

      const delayNode = audioCtx.createDelay();
      delayNode.delayTime = parseFloat(delayCtrl.value);
      const feedbackNode = audioCtx.createGain();
      feedbackNode.gain.value = parseFloat(echoCtrl.value);
      delayNode.connect(feedbackNode).connect(delayNode);
      delayNode.connect(reverbNode);

      const detuneOffsets = [-10, -5, 0, 5, 10];
      detuneOffsets.forEach(off => {
        const osc = audioCtx.createOscillator();
        osc.type = "square";
        osc.frequency.setValueAtTime(freqVal, now);
        osc.detune.setValueAtTime(off, now);
        chorusGain.connect(osc.detune);

        const gainNode = audioCtx.createGain();
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(0.3, now + 0.3);
        gainNode.gain.linearRampToValueAtTime(0, now + 3);

        const panNode = audioCtx.createStereoPanner();
        panNode.pan.value = off / 10;

        osc.connect(gainNode);
        gainNode.connect(panNode).connect(filterNode);
        gainNode.connect(analyser);
        gainNode.connect(masterGain);
        filterNode.connect(delayNode);

        osc.start(now); osc.stop(now + 3);
      });
    }

    function scheduleNotes(scale) {
      clearInterval(bpmTimer);
      bpmTimer = setInterval(() => {
        if (!stopped) {
          const f = scale[Math.floor(Math.random() * scale.length)];
          playTone(f);
        }
      }, 60000 / parseInt(bpmCtrl.value));
    }

    function animate() {
      requestAnimationFrame(animate);
      analyser.getByteTimeDomainData(dataArray);
      ctx.fillStyle = "rgba(0,0,0,0.05)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      if (trailFrames.length > 12) trailFrames.shift();
      trailFrames.push([...dataArray]);

      const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      gradient.addColorStop(0, currentWaveColor);
      gradient.addColorStop(1, "#000000");

      for (let t = 0; t < trailFrames.length; t++) {
        const data = trailFrames[t];
        ctx.beginPath();
        let x = 0;
        const slice = canvas.width / data.length;
        for (let i = 0; i < data.length; i++) {
          const v = (data[i] - 128) / 128.0;
          const y = (v * canvas.height / 2.0 * 0.9) + canvas.height / 2;
          i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          x += slice;
        }
        ctx.strokeStyle = gradient;
        ctx.globalAlpha = 0.05 + (t / trailFrames.length) * 0.1;
        ctx.shadowBlur = 16;
        ctx.shadowColor = currentWaveColor;
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1.0;
      }
    }

    playBtn.addEventListener("click", () => {
      initAudio();
      stopped = false;
      currentWaveColor = getColor();
      const scale = getScale();
      playTone(scale[Math.floor(Math.random() * scale.length)]);
      scheduleNotes(scale);
    });

    stopBtn.addEventListener("click", () => {
      stopped = true;
      clearInterval(bpmTimer);
    });

    bpmCtrl.addEventListener("input", e => {
      if (!stopped) scheduleNotes(getScale());
    });

    preset.addEventListener("change", () => {
      currentWaveColor = getColor();
      if (!stopped) scheduleNotes(getScale());
    });

    reverbCtrl.addEventListener("input", e => {
      if (reverbFeedback) reverbFeedback.gain.value = parseFloat(e.target.value);
      if (reverbNode) reverbNode.delayTime = parseFloat(e.target.value);
    });

    toggleBtn.addEventListener("click", () => {
      infoDisplay.style.display = infoDisplay.style.display === "none" ? "block" : "none";
    });

    // Display updates
    let currentWaveColor = getColor();
    setInterval(() => {
      infoDisplay.textContent =
        "PRESET : " + preset.value + "\n" +
        "DELAY  : " + delayCtrl.value + "\n" +
        "ECHO   : " + echoCtrl.value + "\n" +
        "REVERB : " + reverbCtrl.value + "\n" +
        "FILTER : " + filterCtrl.value + "\n" +
        "FREQ   : " + freqCtrl.value + "\n" +
        "VOLUME : " + volumeCtrl.value + "\n" +
        "BPM    : " + bpmCtrl.value;
    }, 250);

  </script>
</body>
</html>
